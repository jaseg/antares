tmgr: Простейший планировщик задач
----------------------------------

Описание
--------

Планировщик задач удобно использовать в том случае, если ваша программа логично
разбивается нa несколько отдельных потоков или циклично выполняемых блоков.
В таком случае планировщик предоставляет возможность сделать работу с потоками
максимально прозрачной.

Особенности
-----------

* Максимальная простота обращения с точки зрения пользователя

* Кроссплатформенность (реализация полностью на Си, без ассемблера)

* Конфигурируемость (например, размер переменной для хранения времени
                     устанавливается пользователем)

Как использовать?
-----------------

1. Инициализация
----------------

Работа планировщика организуется циклическими вызовами двух функций:
tmgr_tick() и tmgr_timer().

Функцию tmgr_timer() следует вызывать в обработчике прерывания таймера, который 
отсчитывает кванты времени планировщика. Оптимальным размером кванта времени 
автор считает 1 мс (соответственно, частота вызова функции tmgr_timer() будет
1 кГц). Эта функция обеспечивает только отсчёт времени (в зависимости от режима
работы планировщика) и минимально загружает систему в контексте прерывания.

Функцию tmgr_tick() следует вызывать в основном цикле программы. В рамках вызова
этой функции будет происходить выполение задач пользователя, так что её вызов
в контексте прерывания не рекомендуется.

Для функции конвертирования времени требуется передать библиотеке значение частоты
системного таймера (в Гц). Это делается вызовом функции tmgr_set_fq(). Например,

        tmgr_set_fq(1000);

означает, что системный таймер будет вызывать прерывание с частотой 1 кГц.
Замечание: Планировщик _не инициализирует_ таймер. Инициализация системного
таймера и организация вызовов функций планировщика лежит на пользователе.

Функция tmgr_set_fq() принимает в качестве аргумента одно значение типа tmgr_time_t
(целый знаковый, размер которого можно установить в меню конфигурации menuconig).

Пример программы, обеспечивающей корректную работу таймера:

#include <lib/tmgr.h>

void timer_interrupt()
{
        /* Прерывание системного таймера (абстрактно) */
        tmgr_timer();
}

int main(void)
{
        /* Инициализация системного таймера, платформо-зависима */
        timer_init(1000);
        /* Пусть таймер работает на частоте 1 кГц (квант времени 1 мс) */
        /* Передаём это значение планировщику */
        tmgr_set_fq(1000);
        
        /* Вызов основной функции планировщика в бесконечном цикле */
        while (1)
                tmgr_tick();

        return 0;
}

2. Работа с планировщиком
-------------------------

Всё максимально просто. Планировщику требуется знать, какую функцию вы хотите
запустить (функция не должна ничего принимать и возвращать: void foo(void);) и
c какой задержкой. От вас также потребуется одна переменная типа tmgr_task_t
(на самом деле, это структура, но вся работа с ней происходит внутри библиотеки
и вам не нужно обращаться к её элементам) в _статической_ памяти.

Для того, чтобы поместить задачу в очередь планировщика, в нужном месте кода
сделайте вызов:

        tmgr_register(&my_task, my_func_name, delay);

Здесь my_task - это переменная типа tmgr_task_t (в статической памяти), 
my_func_name - имя функции, которую потребуется выполнить, delay - задержка
запуска.

В общем случае задержка запуска считается в тиках системного таймера. Для того,
чтобы выразить задержку в нормальных единицах времени, следует использовать
макросы конвертирования времени планировщика:

        tmgr_us_to_ticks(us)
        tmgr_ms_to_ticks(ms)
        tmgr_s_to_ticks(s)

Существуют также и макросы обратного конвертирования:
        
        tmgr_ticks_to_us(ticks)
        tmgr_ticks_to_ms(ticks)
        tmgr_ticks_to_s(ticks)

Время (число тиков, а также нормальных единиц) определяется типом данных
tmgr_time_t (целый знаковый, размер устанавливается пользователем в меню
конфигурации menuconfig). Таким образом, все функции конвертирования времени
принимают и возвращают tmgr_time_t.

Таким образом, вызов функции my_func с задержкой 500 мс будет выглядеть так:

        static tmgr_task_t my_task;
        tmgr_register(&my_task, my_func, tmgr_ms_to_ticks(500));


3. Режимы работы планировщика
-----------------------------

Планировщик имеет два режима работы: прямого и обратного отсчёта времени
(соответственно, uptime counter и countdown)

3.1. Прямой отсчёт времени (uptime)
-----------------------------------

В этом режиме работы основанием отсчёта времени является значение "времени
работы" (uptime) программы. При этом пользователь может в любой момент узнать
текущее значение uptime, вызвав функцию

        tmgr_get_uptime().

Замечание. Функция tmgr_get_update() доступна только в этом режиме работы.

Функция возвращает тип tmgr_time_t (целочисленный знаковый, размер которого
устанавливается пользователем в меню конфигурации menuconfig).

Такой метод работы быстрее (в прерывании происходит только инкрементирование
значения переменной uptime, в основном цикле программы вызов задачи происходит
при совпадении текущего значения uptime с подсчитанным при регистрации). Однако,
он имеет очевидное ограничение на общее время работы устройства (возможность
переполнения переменной, считающий uptime).

Отсчитанное время хранится в переменной типа tmgr_time_t. Это целый знаковый тип,
размер которого можно установить в меню конфигурации menuconfig.
Возможно использование 16, 32 и 64-битной переменной.

Предельное время стабильной работы в uptime-режиме в зависимости от размера
переменной (частота системного таймера - 1 кГц):

        16 бит - 32.767 секунд.
        32 бит - 2147483.65 с ~ 596 ч ~ 25 суток
        64 бит - 10^11 суток

3.2. Обратный отсчёт времени (countdown)
----------------------------------------

Этот режим работы немного медленней, чем uptime, так как суть его работы
заключается в декрементировании значений таймера каждой задачи в отдельности,
зато отсутствуют ограничения на время работы.

В этом режиме также нужно установить размер переменной времени (по вашему
усмотрению).

3.3. Вывод
----------

Если целевая архитектура позволяет достаточно быстро работать с 64-битными
переменными, или время непрерывной работы вашего устройства не превысит 25 
суток, то есть смысл использовать первый режим работы как более быстрый и
предоставляющий больше возможностей. Если же устройство должно проработать
непрерывно достаточно долго, но нет возможности использовать 64-битные
переменные, то можно выбрать режим countdown (правда, при увеличении количества
задач в очереди время работы в прерывании системного таймера будет линейно расти,
так что стоит серьёзно подумать о выборе режима).

Замечание. Общий принцип работы с планировщиком одинаков в обоих режимах.
(Единственное отличие - отсутствие функции tmgr_get_uptime() во втором режиме).
Таким образом, в большинстве случаев можно практически без изменений в коде
программы изменить способ функционирования планировщика.


4. Описание параметров планировщика (menuconfig)
------------------------------------------------

Параметров всего два.

4.1. Mode of operation
----------------------
Режим работы таймера. Выбирается из двух (Uptime и Countdown), описание выше.

4.2. Time variable size
-----------------------
Размер переменной для хранения времени. Описание выше (Режимы работы).


5. Дополнительные возможности
-----------------------------

У планировщика есть функция tmgr_delay(delay). Она обеспечивает простую
задержку работы программы на нужный промежуток времени. В качестве единственного
аргумента функция принимает число тиков системного таймера, которые нужно
прождать. (С помощью функций конвертирования времени можно записывать время
задержки в стандартных единицах). Например, вызов

        tmgr_delay(tmgr_ms_to_ticks(500));

обеспечит остановку работы программы на 500 мс.

Принимаемый параметр имеет тип tmgr_time_t, неоднократно описанный выше.

Замечание. Использование этой функции с планировщиком НЕ РЕКОМЕНДУЕТСЯ.
Особенно в рамках вызываемых задач. Всё дело в том, что во время задержки
прерывается нормальное выполнение задач в планировщике (данный способ
задержки просто в цикле ждёт нужный момент времени, "подвешивая"
процессор.)

Функцию tmgr_get_fq() можно использовать для того, чтобы в любой момент
времени получить установленное ранее значение частоты системного таймера.
Возвращаемый тип - tmgr_time_t.
